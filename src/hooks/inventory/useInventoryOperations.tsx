// src/hooks/inventory/useInventoryOperations.tsx
"use client";

import { useCallback } from "react";
import { Product } from "../../types/product";
import { InventoryItem, EmployeeContext } from "./types";

interface UseInventoryOperationsProps {
  inventory: InventoryItem[];
  setInventory: React.Dispatch<React.SetStateAction<InventoryItem[]>>;
  saveInventory: (data: InventoryItem[]) => boolean;
  employeeContext?: EmployeeContext;
  setError: (error: string | null) => void;
}

export const useInventoryOperations = ({
  inventory,
  setInventory,
  saveInventory,
  employeeContext,
  setError,
}: UseInventoryOperationsProps) => {
  // Helper function to map category to product group
  const mapCategoryToProductGroup = useCallback((category: string): string => {
    const categoryMapping: Record<string, string> = {
      beverages: "STM",
      dairy: "EVAP",
      confectionery: "Gummy",
      snacks: "SNACK",
      canned_food: "EVAP",
      // à¹€à¸žà¸´à¹ˆà¸¡à¸à¸²à¸£ mapping à¸•à¸²à¸¡à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸à¸²à¸£
    };

    return categoryMapping[category.toLowerCase()] || "OTHER";
  }, []);

  // Add or update inventory item with employee info
  const addOrUpdateItem = useCallback(
    (product: Product, quantity: number, barcodeType?: "ea" | "dsp" | "cs") => {
      if (!product || quantity <= 0) {
        setError("à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸ªà¸´à¸™à¸„à¹‰à¸²à¸«à¸£à¸·à¸­à¸ˆà¸³à¸™à¸§à¸™à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡");
        return false;
      }

      try {
        setError(null);

        const newItem: InventoryItem = {
          id: `${product.barcode}_${barcodeType || "ea"}_${Date.now()}`,
          barcode: product.barcode,
          productName: product.name,
          brand: product.brand,
          category: product.category,
          size: product.size || "",
          unit: product.unit || "",
          quantity: quantity,
          lastUpdated: new Date().toISOString(),
          productData: product,
          addedBy: employeeContext?.employeeName,
          branchCode: employeeContext?.branchCode,
          branchName: employeeContext?.branchName,
          // à¹€à¸žà¸´à¹ˆà¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸«à¸¡à¹ˆ
          barcodeType: barcodeType || "ea",
          materialCode: product.sku || product.id,
          productGroup: mapCategoryToProductGroup(product.category),
          thaiDescription: product.description || product.name,
        };

        setInventory((prevInventory) => {
          // à¸„à¹‰à¸™à¸«à¸² item à¸—à¸µà¹ˆà¸¡à¸µ barcode à¹à¸¥à¸° type à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™
          const existingIndex = prevInventory.findIndex(
            (item) =>
              item.barcode === product.barcode &&
              item.barcodeType === (barcodeType || "ea")
          );

          let updatedInventory: InventoryItem[];

          if (existingIndex !== -1) {
            updatedInventory = prevInventory.map((item, index) =>
              index === existingIndex
                ? {
                    ...item,
                    quantity: item.quantity + quantity,
                    lastUpdated: new Date().toISOString(),
                    productData: product,
                    addedBy: employeeContext?.employeeName || item.addedBy,
                    branchCode: employeeContext?.branchCode || item.branchCode,
                    branchName: employeeContext?.branchName || item.branchName,
                  }
                : item
            );
            console.log(
              `ðŸ“¦ Updated existing item: ${product.name} (+${quantity}) ${
                barcodeType || "ea"
              } by ${employeeContext?.employeeName}`
            );
          } else {
            updatedInventory = [...prevInventory, newItem];
            console.log(
              `ðŸ“¦ Added new item: ${product.name} (${quantity}) ${
                barcodeType || "ea"
              } by ${employeeContext?.employeeName}`
            );
          }

          saveInventory(updatedInventory);
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("âŒ Error adding/updating item:", err);
        setError("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¹€à¸žà¸´à¹ˆà¸¡à¸ªà¸´à¸™à¸„à¹‰à¸²");
        return false;
      }
    },
    [
      saveInventory,
      employeeContext,
      setError,
      setInventory,
      mapCategoryToProductGroup,
    ]
  );

  // Update specific item quantity
  const updateItemQuantity = useCallback(
    (itemId: string, newQuantity: number) => {
      if (newQuantity < 0) {
        setError("à¸ˆà¸³à¸™à¸§à¸™à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸² 0");
        return false;
      }

      try {
        setError(null);

        setInventory((prevInventory) => {
          const updatedInventory = prevInventory
            .map((item) =>
              item.id === itemId
                ? {
                    ...item,
                    quantity: newQuantity,
                    lastUpdated: new Date().toISOString(),
                    // à¸­à¸±à¸žà¹€à¸”à¸•à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸žà¸™à¸±à¸à¸‡à¸²à¸™à¸—à¸µà¹ˆà¹à¸à¹‰à¹„à¸‚
                    addedBy: employeeContext?.employeeName || item.addedBy,
                  }
                : item
            )
            .filter((item) => item.quantity > 0); // Remove items with 0 quantity

          saveInventory(updatedInventory);
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("âŒ Error updating item quantity:", err);
        setError("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸­à¸±à¸žà¹€à¸”à¸•à¸ˆà¸³à¸™à¸§à¸™");
        return false;
      }
    },
    [saveInventory, employeeContext, setError, setInventory]
  );

  // Remove specific item
  const removeItem = useCallback(
    (itemId: string) => {
      try {
        setError(null);

        setInventory((prevInventory) => {
          const updatedInventory = prevInventory.filter(
            (item) => item.id !== itemId
          );
          saveInventory(updatedInventory);
          console.log(
            "ðŸ—‘ï¸ Removed item:",
            itemId,
            "by",
            employeeContext?.employeeName
          );
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("âŒ Error removing item:", err);
        setError("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸¥à¸šà¸ªà¸´à¸™à¸„à¹‰à¸²");
        return false;
      }
    },
    [saveInventory, employeeContext, setError, setInventory]
  );

  // Clear all inventory
  const clearInventory = useCallback(() => {
    try {
      setError(null);
      setInventory([]);
      saveInventory([]);
      console.log("ðŸ—‘ï¸ Cleared all inventory by", employeeContext?.employeeName);
      return true;
    } catch (err: any) {
      console.error("âŒ Error clearing inventory:", err);
      setError("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”");
      return false;
    }
  }, [saveInventory, employeeContext, setError, setInventory]);

  // Search and utility functions
  const findItemByBarcode = useCallback(
    (barcode: string) => {
      return inventory.find((item) => item.barcode === barcode);
    },
    [inventory]
  );

  const searchItems = useCallback(
    (searchTerm: string) => {
      const term = searchTerm.toLowerCase();
      return inventory.filter(
        (item) =>
          item.productName.toLowerCase().includes(term) ||
          item.brand.toLowerCase().includes(term) ||
          item.barcode.includes(term) ||
          item.category.toLowerCase().includes(term)
      );
    },
    [inventory]
  );

  return {
    // CRUD Operations
    addOrUpdateItem,
    updateItemQuantity,
    removeItem,
    clearInventory,

    // Search & Utilities
    findItemByBarcode,
    searchItems,
  };
};
