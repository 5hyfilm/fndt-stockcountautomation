// Path: src/hooks/inventory/useInventoryOperations.tsx - Cleaned Version (No Legacy Code)
"use client";

import { useCallback } from "react";
import { Product } from "../../types/product";
import {
  InventoryItem,
  QuantityInput,
  QuantityDetail,
  MultiUnitQuantities,
  getTotalQuantityAllUnits,
  isQuantityDetail,
} from "../../types/inventory";

interface UseInventoryOperationsProps {
  inventory: InventoryItem[];
  setInventory: (inventory: InventoryItem[]) => void;
  saveInventory: (inventory: InventoryItem[]) => boolean;
  setError: (error: string | null) => void;
}

export const useInventoryOperations = ({
  inventory,
  setInventory,
  saveInventory,
  setError,
}: UseInventoryOperationsProps) => {
  // ‚úÖ Generate unique material code for new products
  const generateMaterialCode = useCallback((product: Product): string => {
    return product.name || product.barcode || `MAT_${Date.now()}`;
  }, []);

  // ‚úÖ Find item by material code (‡∏´‡∏•‡∏±‡∏Å)
  const findItemByMaterialCode = useCallback(
    (materialCode: string): InventoryItem | undefined => {
      return inventory.find((item) => item.materialCode === materialCode);
    },
    [inventory]
  );

  // ‚úÖ Find item by barcode (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö multi-barcode)
  const findItemByBarcode = useCallback(
    (barcode: string): InventoryItem | undefined => {
      return inventory.find(
        (item) =>
          item.barcode === barcode ||
          item.scannedBarcodes?.cs === barcode ||
          item.scannedBarcodes?.dsp === barcode ||
          item.scannedBarcodes?.ea === barcode
      );
    },
    [inventory]
  );

  // ‚úÖ Add or update multi-unit item with QuantityDetail support
  const addOrUpdateMultiUnitItem = useCallback(
    (
      product: Product,
      quantityInput: QuantityInput,
      barcodeType: "cs" | "dsp" | "ea",
      directProductGroup?: string
    ): boolean => {
      try {
        setError(null);

        // ‚úÖ Parse quantity input with QuantityDetail support
        let quantities: MultiUnitQuantities = {};

        if (typeof quantityInput === "number") {
          // Simple number input
          quantities[barcodeType] = quantityInput;
          console.log(
            "üìù Simple quantity input:",
            quantityInput,
            "for",
            barcodeType
          );
        } else if ("quantity" in quantityInput && "unit" in quantityInput) {
          // Unit-specific input: { quantity: number, unit: string }
          const unitInput = quantityInput as {
            quantity: number;
            unit: "cs" | "dsp" | "ea";
          };
          quantities[unitInput.unit] = unitInput.quantity;
          console.log("üìù Unit-specific input:", unitInput);

          // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ unit ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö barcodeType ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
          if (unitInput.unit !== barcodeType) {
            console.warn(
              `Unit mismatch: input=${unitInput.unit}, barcode=${barcodeType}`
            );
          }
        } else if (isQuantityDetail(quantityInput)) {
          // ‚úÖ QuantityDetail input - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö 3 ‡∏´‡∏ô‡πà‡∏ß‡∏¢
          const quantityDetail = quantityInput as QuantityDetail;
          quantities = {
            cs: quantityDetail.cs,
            dsp: quantityDetail.dsp,
            ea: quantityDetail.ea,
          };
          // ‡∏•‡∏ö‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô 0 ‡∏≠‡∏≠‡∏Å
          if (quantities.cs === 0) delete quantities.cs;
          if (quantities.dsp === 0) delete quantities.dsp;
          if (quantities.ea === 0) delete quantities.ea;

          console.log("üìù QuantityDetail input (3-unit):", quantities);
        } else {
          console.error("‚ùå Invalid quantityInput format:", quantityInput);
          setError("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
          return false;
        }

        // ‚úÖ Validate quantities
        const totalQuantity = Object.values(quantities).reduce(
          (sum, qty) => sum + (qty || 0),
          0
        );
        if (totalQuantity <= 0) {
          setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0");
          return false;
        }

        // Generate or get material code
        const materialCode = generateMaterialCode(product);

        console.log(
          "üîç Looking for existing item with materialCode:",
          materialCode
        );
        console.log("üì¶ New quantities to add:", quantities);

        // ‚úÖ Check if item already exists
        const existingItemIndex = inventory.findIndex(
          (item) => item.materialCode === materialCode
        );

        if (existingItemIndex !== -1) {
          // ‚úÖ Update existing item
          const existingItem = inventory[existingItemIndex];
          console.log("üìù Updating existing item:", existingItem.productName);

          const updatedQuantities: MultiUnitQuantities = {
            cs: (existingItem.quantities.cs || 0) + (quantities.cs || 0),
            dsp: (existingItem.quantities.dsp || 0) + (quantities.dsp || 0),
            ea: (existingItem.quantities.ea || 0) + (quantities.ea || 0),
          };

          // Remove zero quantities
          if (updatedQuantities.cs === 0) delete updatedQuantities.cs;
          if (updatedQuantities.dsp === 0) delete updatedQuantities.dsp;
          if (updatedQuantities.ea === 0) delete updatedQuantities.ea;

          const updatedItem: InventoryItem = {
            ...existingItem,
            quantities: updatedQuantities,
            quantity: getTotalQuantityAllUnits({
              ...existingItem,
              quantities: updatedQuantities,
            }),
            lastUpdated: new Date().toISOString(),
            scannedBarcodes: {
              ...existingItem.scannedBarcodes,
              [barcodeType]: product.barcode,
            },
          };

          const newInventory = [...inventory];
          newInventory[existingItemIndex] = updatedItem;
          setInventory(newInventory);
          saveInventory(newInventory);

          console.log("‚úÖ Updated item:", updatedItem.productName);
          return true;
        } else {
          // ‚úÖ Add new item
          const newItem: InventoryItem = {
            id: `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            materialCode,
            productName: product.name || `Product ${product.barcode}`,
            brand: product.brand || "Unknown",
            category: product.category || "Unknown",
            size: product.size || "",
            unit: product.unit || "EA",
            barcode: product.barcode,
            quantities,
            quantity: getTotalQuantityAllUnits({ quantities } as InventoryItem),
            lastUpdated: new Date().toISOString(),
            productData: product,
            productGroup: directProductGroup || "",
            thaiDescription: product.description || "",
            scannedBarcodes: {
              [barcodeType]: product.barcode,
            },
          };

          const newInventory = [...inventory, newItem];
          setInventory(newInventory);
          saveInventory(newInventory);

          console.log("‚úÖ Added new item:", newItem.productName);
          return true;
        }
      } catch (error) {
        console.error("‚ùå Error in addOrUpdateMultiUnitItem:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError, generateMaterialCode]
  );

  // ‚úÖ Update specific unit quantity
  const updateUnitQuantity = useCallback(
    (
      materialCode: string,
      unit: "cs" | "dsp" | "ea",
      newQuantity: number
    ): boolean => {
      try {
        setError(null);

        if (newQuantity < 0) {
          setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î‡∏•‡∏ö");
          return false;
        }

        const itemIndex = inventory.findIndex(
          (item) => item.materialCode === materialCode
        );

        if (itemIndex === -1) {
          setError("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç");
          return false;
        }

        const item = inventory[itemIndex];
        const updatedQuantities = { ...item.quantities };

        if (newQuantity === 0) {
          delete updatedQuantities[unit];
        } else {
          updatedQuantities[unit] = newQuantity;
        }

        const updatedItem: InventoryItem = {
          ...item,
          quantities: updatedQuantities,
          quantity: getTotalQuantityAllUnits({
            ...item,
            quantities: updatedQuantities,
          }),
          lastUpdated: new Date().toISOString(),
        };

        const newInventory = [...inventory];
        newInventory[itemIndex] = updatedItem;
        setInventory(newInventory);
        saveInventory(newInventory);

        console.log(`‚úÖ Updated ${unit} quantity for:`, item.productName);
        return true;
      } catch (error) {
        console.error("‚ùå Error updating unit quantity:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError]
  );

  // ‚úÖ Update item quantity detail
  const updateItemQuantityDetail = useCallback(
    (materialCode: string, quantityDetail: QuantityDetail): boolean => {
      try {
        setError(null);

        const itemIndex = inventory.findIndex(
          (item) => item.materialCode === materialCode
        );

        if (itemIndex === -1) {
          setError("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç");
          return false;
        }

        const item = inventory[itemIndex];
        const updatedQuantities: MultiUnitQuantities = {
          cs: quantityDetail.cs || 0,
          dsp: quantityDetail.dsp || 0,
          ea: quantityDetail.ea || 0,
        };

        // Remove zero quantities
        if (updatedQuantities.cs === 0) delete updatedQuantities.cs;
        if (updatedQuantities.dsp === 0) delete updatedQuantities.dsp;
        if (updatedQuantities.ea === 0) delete updatedQuantities.ea;

        const updatedItem: InventoryItem = {
          ...item,
          quantities: updatedQuantities,
          quantityDetail: {
            ...quantityDetail,
            lastModified: new Date().toISOString(),
          },
          quantity: getTotalQuantityAllUnits({
            ...item,
            quantities: updatedQuantities,
          }),
          lastUpdated: new Date().toISOString(),
        };

        const newInventory = [...inventory];
        newInventory[itemIndex] = updatedItem;
        setInventory(newInventory);
        saveInventory(newInventory);

        console.log("‚úÖ Updated quantity detail for:", item.productName);
        return true;
      } catch (error) {
        console.error("‚ùå Error updating quantity detail:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError]
  );

  // ‚úÖ Remove item from inventory
  const removeItem = useCallback(
    (itemId: string): boolean => {
      try {
        setError(null);

        const newInventory = inventory.filter((item) => item.id !== itemId);
        setInventory(newInventory);
        saveInventory(newInventory);

        console.log("‚úÖ Removed item:", itemId);
        return true;
      } catch (error) {
        console.error("‚ùå Error removing item:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError]
  );

  // ‚úÖ Search items
  const searchItems = useCallback(
    (searchTerm: string): InventoryItem[] => {
      if (!searchTerm.trim()) return inventory;

      const term = searchTerm.toLowerCase().trim();
      return inventory.filter(
        (item) =>
          item.productName.toLowerCase().includes(term) ||
          item.materialCode.toLowerCase().includes(term) ||
          item.brand.toLowerCase().includes(term) ||
          item.barcode.includes(term) ||
          item.category.toLowerCase().includes(term)
      );
    },
    [inventory]
  );

  return {
    // Core operations
    addOrUpdateMultiUnitItem,
    updateUnitQuantity,
    updateItemQuantityDetail,
    removeItem,
    searchItems,

    // Finder methods
    findItemByMaterialCode,
    findItemByBarcode,

    // Utilities
    generateMaterialCode,
  };
};
